using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using W.Common;

namespace W.Expressions.Sql
{
    internal static partial class Preprocessing
    {
        internal struct FieldsInfo
        {
            public IList<Expr> fields;
            public IDictionary<string, object> attrs;
        }

        internal static SqlFuncDefinitionContext NewCodeLookupDict(SqlFuncDefinitionContext src, FieldsInfo tmpl, string codeFieldName)
        {
            var innerAttrs = new List<Dictionary<string, object>>(tmpl.fields.Count + 1);

            var sb = new StringBuilder();
            sb.AppendLine("SELECT");

            {   // first field
                var firstFieldAttrs = new Dictionary<string, object>();
                firstFieldAttrs.Add(nameof(Attr.description), "Dummy key field used for grouping");
                innerAttrs.Add(firstFieldAttrs);
                sb.Append($"\t0  x{codeFieldName.GetHashCode():X}_ID_TMP");
            }

            var substance = codeFieldName.Substring(0, codeFieldName.IndexOf('_'));
            var modFunc = src.ldr.ModifyFieldExpr(src, substance);

            var tmplInnerAttrs = (Dictionary<string, object>[])tmpl.attrs[nameof(Attr.innerAttrs)];

            for (int i = 0; i < tmpl.fields.Count; i++)
            {
                sb.AppendLine(",");
                var fReal = modFunc(tmpl.fields[i]);
                sb.Append($"\t{fReal}");
                innerAttrs.Add(tmplInnerAttrs[i]);
            }

            var xtraAttrs = new Dictionary<string, object>(tmpl.attrs);
            var c = new SqlFuncDefinitionContext()
            {
                ldr = src.ldr,
                actualityInDays = 36525 * 10,
                arrayResults = true,
                funcNamesPrefix = codeFieldName + "_DictData",
                xtraAttrs = xtraAttrs,
                queryText = sb.ToString(),
            };

            xtraAttrs[nameof(Attr.funcPrefix)] = c.funcNamesPrefix;
            Attr.Add(xtraAttrs, nameof(Attr.description), $"Autogenerated description of lookup table for '{codeFieldName}' field");
            xtraAttrs[nameof(Attr.actuality)] = c.actualityInDays;
            xtraAttrs[nameof(Attr.arrayResults)] = true;
            xtraAttrs[nameof(Attr.innerAttrs)] = innerAttrs;

            return c;
        }

        /// <summary>
        /// SQL file processing context
        /// </summary>
        internal class LoadingSqlFuncsContext
        {
            public string sqlFileName;
            public string dbConnValueName;
            public QueryKind forKinds;
            public TimeSpan cachingExpiration;
            public string cacheSubdomain;
            public string defaultLocationForValueInfo;
            public Generator.Ctx ctx;

            readonly Dictionary<string, FieldsInfo> abstracts = new Dictionary<string, FieldsInfo>();
            readonly Dictionary<string, FieldsInfo> CL_templs = new Dictionary<string, FieldsInfo>();

            readonly Dictionary<string, SqlFuncDefinitionContext> extraFuncs = new Dictionary<string, SqlFuncDefinitionContext>();
            readonly List<SqlFuncDefinitionContext> lstAddedExtraFuncs = new List<SqlFuncDefinitionContext>();

            void AddExtraFunc(string name, Func<SqlFuncDefinitionContext> funcGetter)
            {
                // mark name as already added to avoid possible infinite recursion
                extraFuncs.Add(name, null);
                // get value
                var func = funcGetter();
                // set value for name
                extraFuncs[name] = func;
                // 
                lstAddedExtraFuncs.Add(func);
            }

            internal Func<Expr, Expr> ModifyFieldExpr(SqlFuncDefinitionContext src, string substance)
            {
                Func<string, string> subst = s =>
                {
                    switch (s)
                    {
                        case nameof(START_TIME):
                        case nameof(END_TIME):
                        case nameof(END_TIME__DT):
                        case nameof(INS_OUTS_SEPARATOR):
                            return null;
                    }
                    int i = s.IndexOf('_');

                    string desc, quan;
                    if (i < 0)
                    {
                        desc = substance + '_' + s;
                        quan = s;
                    }
                    else
                    {
                        //if (s.Substring(i).All(c => !char.IsLetter(c) || char.IsUpper(c)))
                        //    // if all letters of substance code are in upper case, do not modify
                        //    return null;

                        desc = substance + s;
                        int j = s.IndexOf('_', i + 1);
                        quan = (j < 0) ? s.Substring(i + 1) : s.Substring(i + 1, j - i - 1);
                    }

                    if (CL_templs.TryGetValue(quan, out var fields) && !extraFuncs.ContainsKey(desc))
                        AddExtraFunc(desc, () => NewCodeLookupDict(src, fields, desc));

                    return desc;
                };

                return arg =>
                {
                    string p = null;
                    switch (arg.nodeType)
                    {
                        case ExprType.Alias:
                            var ae = (AliasExpr)arg;
                            if ((p = subst(ae.alias)) == null)
                                return arg;
                            return new AliasExpr(ae.expr, new ReferenceExpr(p));
                        case ExprType.Sequence:
                            var args = ((SequenceExpr)arg).args;
                            int n = args.Count;
                            if ((p = subst(args[n - 1].ToString())) == null)
                                return arg;
                            return new SequenceExpr(args.Take(n - 1).Concat(new[] { new ReferenceExpr(p) }).ToList());
                        case ExprType.Reference:
                            var re = (ReferenceExpr)arg;
                            if ((p = subst(re.name)) == null)
                                return arg;
                            return new AliasExpr(re, new ReferenceExpr(p));
                        default:
                            return arg;
                    }
                };
            }

            IEnumerable<FuncDef> SqlFuncDefAction(string funcNamePrefix, int actualityInDays, string queryText, bool arrayResults, IDictionary<string, object> xtraAttrs)
            {
                var c = new SqlFuncDefinitionContext()
                {
                    ldr = this,
                    funcNamesPrefix = funcNamePrefix,
                    actualityInDays = actualityInDays,
                    queryText = queryText,
                    arrayResults = arrayResults,
                    xtraAttrs = xtraAttrs,
                };
                var fds = Impl.FuncDefsForSql(c);

                if (lstAddedExtraFuncs.Count > 0)
                {   // some extra functions/tables autogenerated
                    foreach (var fdc in lstAddedExtraFuncs)
                        foreach (var fd in Impl.FuncDefsForSql(fdc))
                            yield return fd;
                }

                foreach (var fd in fds)
                    yield return fd;
            }

            public IEnumerable<FuncDef> LoadingFuncs()
            {
                foreach (var fdEnum in Impl.ParseSqlFuncs(sqlFileName, SqlFuncDefAction, ctx))
                    foreach (var fd in fdEnum)
                        yield return fd;
            }

            static class AbstractTable { }
            static class Substance { }
            static class Inherits { }
            static class LookupTableTemplate { }

            internal Expr PostProcSelect(SqlFuncDefinitionContext c, SqlSectionExpr sqlSection)
            {
                bool aliasesFixedByDefault = false;

                if (c.xtraAttrs.TryGetValue(nameof(AbstractTable), out var objAbstractTable))
                    aliasesFixedByDefault = true;

                if (c.xtraAttrs.TryGetValue(nameof(LookupTableTemplate), out var objLookupTableTemplate))
                    aliasesFixedByDefault = true;

                var modFunc = c.xtraAttrs.TryGetValue(nameof(Substance), out var objSubstance)
                    ? ModifyFieldExpr(c, objSubstance.ToString())
                    : x => x;

                #region Postprocess SELECT expression: insert inherited fields if needed
                if (c.xtraAttrs.TryGetValue(nameof(Attr.innerAttrs), out var objInnerAttrs))
                {
                    var innerAttrs = (Dictionary<string, object>[])objInnerAttrs;
                    var args = sqlSection.args;

                    bool changed = false;
                    int n = innerAttrs.Length;
                    var newInner = new List<Dictionary<string, object>>(n);
                    var fields = new List<Expr>(n);

                    for (int i = 0; i < n; i++)
                    {
                        var attrs = innerAttrs[i];
                        if (attrs != null && attrs.TryGetValue(nameof(Inherits), out var objInherits))
                        {   // inherit lot of fields from abstract tables
                            var lst = objInherits as IList;
                            if (lst == null)
                                lst = new object[] { objInherits };
                            foreach (var aT in lst)
                            {
                                if (!abstracts.TryGetValue(aT.ToString(), out var abstr))
                                    throw new Generator.Exception($"No one AbstractTable='{aT}' found");

                                var inheritedFields = abstr.fields;
                                // inherit fields
                                changed = true;
                                if (abstr.attrs.TryGetValue(nameof(Attr.innerAttrs), out var objInners))
                                {
                                    var inners = (Dictionary<string, object>[])objInners;
                                    int k = inheritedFields.Count;
                                    for (int j = 0; j < k; j++)
                                    {   // check every inherited field modifiability
                                        var fieldAttrs = inners[j];
                                        if (Attr.GetBool(fieldAttrs, nameof(Attr.fixedAlias), aliasesFixedByDefault))
                                            fields.Add(inheritedFields[j]);
                                        else
                                            fields.Add(modFunc(inheritedFields[j]));
                                    }
                                    // inherit fields attributes
                                    newInner.AddRange(inners);
                                }
                                else
                                {
                                    fields.AddRange(inheritedFields.Select(modFunc));
                                    // no attributes to inherit
                                    for (int j = inheritedFields.Count - 1; j >= 0; j--)
                                        newInner.Add(null);
                                }
                            }

                        }
                        if (i < args.Count)
                        {   // add field
                            if (Attr.GetBool(attrs, nameof(Attr.fixedAlias), aliasesFixedByDefault))
                                fields.Add(args[i]);
                            else
                                fields.Add(modFunc(args[i]));
                        }
                        newInner.Add(attrs);
                    }
                    if (changed)
                    {
                        // inherited fields added, create updated SELECT expression
                        sqlSection = new SqlSectionExpr(SqlSectionExpr.Kind.Select, fields);
                        c.xtraAttrs[nameof(Attr.innerAttrs)] = newInner.ToArray();
                    }
                }
                else if (objSubstance != null && !aliasesFixedByDefault)
                    sqlSection = new SqlSectionExpr(SqlSectionExpr.Kind.Select, sqlSection.args.Select(modFunc).ToList());
                #endregion


                if (objAbstractTable != null)
                {   // It is "abstract table", add to abstracts dictionary
                    var abstractTable = objAbstractTable.ToString();
                    abstracts.Add(abstractTable, new FieldsInfo() { fields = sqlSection.args, attrs = c.xtraAttrs });
                    return null;
                }

                if (objLookupTableTemplate != null)
                {
                    var ltt = objLookupTableTemplate.ToString();
                    CL_templs.Add(ltt, new FieldsInfo() { fields = sqlSection.args, attrs = c.xtraAttrs });
                    return null;
                }

                return sqlSection;
            }
        }

        /// <summary>
        /// SQL query to functions converter context 
        /// </summary>
        internal class SqlFuncDefinitionContext
        {
            public LoadingSqlFuncsContext ldr;

            public string funcNamesPrefix;
            public double actualityInDays;
            public string queryText;
            public bool arrayResults;
            public IDictionary<string, object> xtraAttrs;

            public Expr PostProc(Expr e)
            {
                var sqlSection = (e.nodeType == ExprType.Call) ? e as SqlSectionExpr : null;
                if (sqlSection != null && sqlSection.kind == SqlSectionExpr.Kind.Select)
                {
                    e = ldr.PostProcSelect(this, sqlSection);
                    if (e == null)
                        return null;
                }

                if (e.nodeType != ExprType.Alias)
                    return e;
                var r = ((AliasExpr)e).right as ReferenceExpr;
                if (r == null)
                    return e;
                var d = r.name.ToUpperInvariant();
                switch (d)
                {
                    case nameof(START_TIME):
                    case nameof(END_TIME):
                    case nameof(END_TIME__DT):
                    case nameof(INS_OUTS_SEPARATOR):
                        // skip special fields
                        return e;
                }
                var vi = ValueInfo.Create(d, true, ldr.defaultLocationForValueInfo);
                if (vi == null) return e;
                var v = vi.ToString();
                if (v == d)
                    return e;
                return new ReferenceExpr(v);
            }
        }
    }

}